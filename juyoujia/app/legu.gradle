import groovy.io.FileType

ext {
    APK_DIR = rootDir.getPath() + "/app/build/outputs/apk/"
    LEGU_JAR_PATH = rootDir.getPath() + "/legu/ms-shield.jar"
    SIGN_JAR_PATH = rootDir.getPath() + "/legu/apksigner.jar"
    ZIPALIGN_PATH = rootDir.getPath() + "/legu/zipalign"
    SECRET_ID = "AKIDawHLJ0vu6C1ZBUnfN6Y3HI5brqYzo3ji"//这里是自己的乐固 secret_id
    SECRET_KEY = "qSloc9RRFn68xiLkwsXv1tUv73j8HRLy"//这里是乐固key
}

println APK_DIR
println LEGU_JAR_PATH
println SIGN_JAR_PATH
println ZIPALIGN_PATH
/**
 * 查找最新的apk文件且是release
 * @return apk路径
 */
File findNewestApk() {
    File apkDir = new File(APK_DIR)
    long lastTime = 0
    File resultFile = null
    apkDir.eachFileRecurse(FileType.FILES) { file ->
        String p = "${rootProject.ext.versionCode}.apk";
        if (file.lastModified() > lastTime && file.name.endsWith(p)) {
            resultFile = file
            lastTime = file.lastModified()
        }
    }
    return resultFile
}

/**
 * 乐固加固
 * @param apk 加固的原始apk File
 */
def reinforce(File apkFile) {
    boolean isJenkinsPack = true
    String server_type = System.getProperty("SERVER_TYPE")
    if (null == server_type || "" == server_type) {
        isJenkinsPack = false
    }
    println "*************** 开始加固 ***************"
    String newApkPath = apkFile.getParent() + "/" + apkFile.getName().replace(".apk", "") + "_legu.apk"
    //jiagu.db中缓存了多渠道信息，如果不删除会合并到当前多渠道配置
    def shield = new File(LEGU_JAR_PATH)
    if (!shield.exists()) {
        throw new RuntimeException("jar not exists!")
    }
    exec {
        if (isWindows() && !isJenkinsPack) {
            commandLine "powershell", "java -jar", LEGU_JAR_PATH, "-sid", SECRET_ID, "-skey", SECRET_KEY, "-uploadPath", apkFile.getPath(), "-downloadPath", apkFile.getParent()
        } else {
            commandLine "java", "-Dfile.encoding=utf-8", "-jar", shield.getAbsolutePath(), "-sid", SECRET_ID, "-skey", SECRET_KEY, "-uploadPath", apkFile.getPath(), "-downloadPath", apkFile.getParent()
        }
    }
    println "*************** 加固完成 ***************"
    return new File(newApkPath)
}

/**
 * 是否是window系统
 * @return
 */
def isWindows() {
    return org.gradle.internal.os.OperatingSystem.current().isWindows()
}

/**
 * zipalign优化
 *
 * @param output
 * @return
 */
def zipalignApk(File apkFile) {
    boolean isJenkinsPack = true
    String server_type = System.getProperty("SERVER_TYPE")
    if (null == server_type || "" == server_type) {
        isJenkinsPack = false
    }
    println "*************** zipalign优化开始 ***************"
    String newApkPath = apkFile.getParent() + "/" + apkFile.getName().replace(".apk", "") + "_zip.apk"
    exec {
        if (isWindows() && !isJenkinsPack) {
            commandLine "powershell", ZIPALIGN_PATH, "-v", "-p", "4", apkFile.getPath(), newApkPath
        } else {
            commandLine ZIPALIGN_PATH, "-v", "-p", "4", apkFile.getPath(), newApkPath
        }
    }
    println "*************** zipalign优化完成 ***************"
    return new File(newApkPath)
}

/**
 * 对apk进行签名
 *
 * @param output
 */
File signApk(File apkFile) {
    boolean isJenkinsPack = true
    String server_type = System.getProperty("SERVER_TYPE")
    if (null == server_type || "" == server_type) {
        isJenkinsPack = false
    }
    println "*************** 开始签名 ***************"
    def timeStamp = new Date().format("yyyy-MM-dd_HH-mm-ss", TimeZone.getTimeZone("GMT+8"));
    String newApkPath = apkFile.getParent() + "/" + apkFile.getName().replace("legu.apk", "") + timeStamp + ".apk"
    println "new apk path:" + newApkPath
    String keyPath = rootDir.getPath() + "/jyjKeyStore.jks"
    String alias = "jyjkey"
    String password = "jyj!@#123"

    println "keyPath:" + keyPath
    println "alias:" + alias
    println "password:" + password
    exec {
        if (isWindows() && !isJenkinsPack) {
            commandLine "powershell", "java", "-jar", SIGN_JAR_PATH, "sign", "--ks", keyPath, "--ks-key-alias", alias, "--ks-pass", "pass:" + password, "--key-pass", "pass:" + password, "--out", newApkPath, apkFile.getPath()
        } else {
            commandLine "java", "-Dfile.encoding=utf-8", "-jar", SIGN_JAR_PATH, "sign", "--ks", keyPath, "--ks-key-alias", alias, "--ks-pass", "pass:" + password, "--key-pass", "pass:" + password, "--out", newApkPath, apkFile.getPath()
        }
    }
    println "*************** 签名完成 ***************"
    return new File(newApkPath)
}


gradle.taskGraph.whenReady { TaskExecutionGraph taskGraph ->
    taskGraph.getAllTasks().each { Task task ->
        if (task.name.startsWith('assemble') && task.name.endsWith('Release')) {
            task.doLast {
                File apkFile = findNewestApk()
                if (apkFile.exists()) {
                    println apkFile.getPath()
                    File leguFile = reinforce(apkFile)
                    //File zipFile = zipalignApk(leguFile)
                    File signedApkFile = signApk(leguFile)
                    apkFile.delete()
                    leguFile.delete()
                }
            }
        }
    }
}